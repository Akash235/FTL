/* Pi-hole: A black hole for Internet advertisements
*  (c) 2018 Pi-hole, LLC (https://pi-hole.net)
*  Network-wide ad blocking via your own hardware.
*
*  API
*  API Configuration
*
*  This file is copyright under the latest version of the EUPL.
*  Please see LICENSE file for your rights under this license. */

use std::collections::HashMap;
use std::fs::{File, OpenOptions};
use std::os::unix::fs::OpenOptionsExt;
use std::io;
use std::path::Path;

/// The API config options
#[derive(Deserialize, Default)]
pub struct ConfigOptions {
    #[serde(default)]
    file_locations: Files
}

impl ConfigOptions {
    /// Get the configured location of a file
    fn file_location(&self, file: PiholeFile) -> &str {
        match file {
            PiholeFile::DnsmasqMainConfig => &self.file_locations.dnsmasq_main_config,
            PiholeFile::Whitelist => &self.file_locations.whitelist,
            PiholeFile::Blacklist => &self.file_locations.blacklist,
            PiholeFile::Regexlist => &self.file_locations.regexlist,
            PiholeFile::SetupVars => &self.file_locations.setup_vars,
            PiholeFile::LocalVersions => &self.file_locations.local_versions,
            PiholeFile::LocalBranches => &self.file_locations.local_branches
        }
    }
}

/// Defines the deserialization of the "file_locations" section of the config file.
/// The default functions are generated by `default!`.
#[derive(Deserialize)]
pub struct Files {
    #[serde(default = "default_dnsmasq_main_config")]
    dnsmasq_main_config: String,
    #[serde(default = "default_whitelist")]
    whitelist: String,
    #[serde(default = "default_blacklist")]
    blacklist: String,
    #[serde(default = "default_regexlist")]
    regexlist: String,
    #[serde(default = "default_setup_vars")]
    setup_vars: String,
    #[serde(default = "default_local_versions")]
    local_versions: String,
    #[serde(default = "default_local_branches")]
    local_branches: String
}

impl Default for Files {
    fn default() -> Self {
        Files {
            dnsmasq_main_config: default_dnsmasq_main_config(),
            whitelist: default_whitelist(),
            blacklist: default_blacklist(),
            regexlist: default_regexlist(),
            setup_vars: default_setup_vars(),
            local_versions: default_local_versions(),
            local_branches: default_local_branches()
        }
    }
}

/// Create an `fn() -> String` default function for deserialization
macro_rules! default {
    ($fn_name:ident, $variant:ident) => {
        fn $fn_name() -> String {
            PiholeFile::$variant.default_location().to_owned()
        }
    };
}

default!(default_dnsmasq_main_config, DnsmasqMainConfig);
default!(default_whitelist, Whitelist);
default!(default_blacklist, Blacklist);
default!(default_regexlist, Regexlist);
default!(default_setup_vars, SetupVars);
default!(default_local_versions, LocalVersions);
default!(default_local_branches, LocalBranches);

/// The files exposed by the `Config`
#[derive(Eq, PartialEq, Hash, Copy, Clone)]
pub enum PiholeFile {
    DnsmasqMainConfig,
    Whitelist,
    Blacklist,
    Regexlist,
    SetupVars,
    LocalVersions,
    LocalBranches
}

impl PiholeFile {
    pub fn default_location(&self) -> &'static str {
        match *self {
            PiholeFile::DnsmasqMainConfig => "/etc/dnsmasq.d/01-pihole.conf",
            PiholeFile::Whitelist => "/etc/pihole/whitelist.txt",
            PiholeFile::Blacklist => "/etc/pihole/blacklist.txt",
            PiholeFile::Regexlist => "/etc/pihole/regex.list",
            PiholeFile::SetupVars => "/etc/pihole/setupVars.conf",
            PiholeFile::LocalVersions => "/etc/pihole/localversions",
            PiholeFile::LocalBranches => "/etc/pihole/localbranches"
        }
    }
}

/// Configuration for the Pi-hole API. Also abstracts away some systems to make testing easier
pub enum Config {
    Production(ConfigOptions), Test(ConfigOptions, HashMap<PiholeFile, File>)
}

impl Config {
    /// Get the location of a file
    pub fn file_location(&self, file: PiholeFile) -> &str {
        match *self {
            Config::Production(ref config_options) => config_options.file_location(file),
            Config::Test(_, _) => file.default_location()
        }
    }

    /// Open a file for reading
    pub fn read_file(&self, file: PiholeFile) -> io::Result<File> {
        match *self {
            Config::Production(_) => {
                File::open(self.file_location(file))
            },
            Config::Test(_, ref map) => {
                match map.get(&file) {
                    Some(data) => data,
                    None => return Err(io::Error::new(io::ErrorKind::NotFound, "Missing test data"))
                }.try_clone()
            }
        }
    }

    /// Open a file for writing. If `append` is false, the file will be truncated.
    pub fn write_file(
        &self,
        file: PiholeFile,
        append: bool
    ) -> io::Result<File> {
        match *self {
            Config::Production(_) => {
                let mut open_options = OpenOptions::new();
                open_options
                    .create(true)
                    .write(true)
                    .mode(0o644);

                if append {
                    open_options.append(true);
                } else {
                    open_options.truncate(true);
                }

                open_options.open(self.file_location(file))
            },
            Config::Test(_, ref map) => {
                let file = match map.get(&file) {
                    Some(data) => data,
                    None => return Err(io::Error::new(io::ErrorKind::NotFound, "Missing test data"))
                }.try_clone()?;

                if !append {
                    file.set_len(0)?;
                }

                Ok(file)
            }
        }
    }

    /// Check if a file exists
    #[allow(unused)]
    pub fn file_exists(&self, file: PiholeFile) -> bool {
        match *self {
            Config::Production(_) => {
                Path::new(self.file_location(file)).is_file()
            },
            Config::Test(_, ref map) => {
                map.contains_key(&file)
            }
        }
    }

    /// Check if we're in a testing environment
    pub fn is_test(&self) -> bool {
        match *self {
            Config::Production(_) => false,
            Config::Test(_, _) => true
        }
    }
}